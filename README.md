# Goro

Goro is a simple Go package that helps working with Concurrency.

## FanOut

Fan-out receives a single channel and multiplex to N channels. `n` goroutines
will be started to read from input and write to outputs channels.

```go
// input = <-chan int
input := generator()

// outputs = []<-chan int
outputs := goro.FanOut(ctx, input, 5)
```

## FanIn

FanIn receives multiples channels (likes generated by `goro.FanOut`) and
returns one channel.

N goroutines will be created, where `N = len(inputs)`

```go
// inputs = []<-chan int
// output = <-chan int
output := goro.FanIn(ctx, inputs)
```

## Map

Map helps when applying functions to channels are necessary. This creates a new
goroutine that will receive a input channel with a function and return a read
channel with another type.

```go

byteCh := ByteStream()

toStr := func(input []byte) string {
    return string(input)
}

strCh := goro.Map(ctx, byteCh, toStr)

for value := range strCh {
    fmt.Println(value)
}
```

## Filter

Filter helps filtering data in one or multiple channels. This function only
returns data thats the filter function returned `true`.

```go
responsesCh := Stream()

badRequest := func(input <-chan http.Response) bool {
    return input.Request.StatusCode == http.StatusBadRequest 
}

// filteredCh only receives data thats filter function 
filteredCh := goro.Filter(ctx, badRequest, responsesCh)
```
